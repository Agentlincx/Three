<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <!--script src="./anim.js" type="module" charset="utf-8"></script-->
  
  <title></title>
</head>
<body>
  
  <canvas style="" id="can1"></canvas>
  
  
  <script type="module">
    
     // import * as gg from '/three.module.js';
  
  import * as gg from 'https://unpkg.com/three@0.139.2/build/three.module.js';


(function() {

  var canvas = document.querySelector('#can1');

  const rend = new gg.WebGLRenderer({
    canvas: canvas,
    antialiasing: true,
    logarithmicDepthBuffer: true,
    shadowMap: true,
    //alpha: true,
    shadowMapType: gg.PCFSoftShadowMap
  });
  rend.shadowMap.enabled = true;
  rend.setClearColor(0x000000,0.96);


  var fov = 75;
  const cam = new gg.PerspectiveCamera(fov,
    0.1,
    1,
    900);
  cam.position.set(0,
    0,
    10);



  //scene
  const scene = new gg.Scene();
  scene.fog = new gg.Fog('white', 20, 100);

  const light = new gg.DirectionalLight('white',
    2);
  light.position.set(-9,
    3,
    9);
  light.castShadow = true;
  scene.add(light);


  var box = new gg.Points(new gg.SphereGeometry(18, 40, 40,), new gg.PointsMaterial({
    side: gg.FrontSide,
    size: 0.01,
    color: "white"
  }));
  scene.add(box);

  //var rew = new OrbitControls(cam,
  //rend.domElement);
  //rew.update();


  var anim;

  (function anim() {

    requestAnimationFrame(anim);

    var canvas = rend.domElement;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;

    cam.aspect = width/height;
    cam.updateProjectionMatrix();

    var needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      rend.setSize(width, height, false);
    }

    box.rotation.x += 0.001;
    box.rotation.y += 0.001;

    rend.render(scene, cam);

    //console.log(vb);
    //ec.render(anim);
  })();



})();

    
  </script>


</body>
</html>
